/**
 * English Quest - Game Avatar Integration System ULTRA-MOBILE
 * Syst√®me d'avatar ultra-int√©gr√© pour cours et jeux
 * Focus: Mobile-first, engagement utilisateur maximum
 */

class GameAvatarIntegration {
  constructor(options = {}) {
    this.options = {
      gameType: 'general',
      showXP: true,
      showReactions: true,
      autoPositioning: true,
      mobileOptimized: true,
      contextualResponses: true,
      courseIntegration: true,
      ...options
    };
    
    this.currentUser = null;
    this.avatarContainer = null;
    this.reactionQueue = [];
    this.isReacting = false;
    this.performanceLevel = 'normal';
    
    // Nouveaux: Syst√®me d'engagement mobile
    this.engagementLevel = 0;
    this.sessionTime = 0;
    this.lastInteraction = Date.now();
    this.touchStartTime = 0;
    
    // Mobile gesture detection
    this.touchStartPos = { x: 0, y: 0 };
    this.isTouchDevice = 'ontouchstart' in window;
    
    this.init();

    // Boot lightweight AI Brain when available
    try {
      this.brain = new AvatarBrain(this, { tts: false });
    } catch (e) {
      console.warn('[AvatarBrain] init skipped:', e);
    }
  }

  async init() {
    console.log('üöÄ [Avatar] Initialisation syst√®me avatar gaming...');
    
    // 1. D√©tection des capacit√©s
    this.detectDeviceCapabilities();
    
    // 2. FORCE RELOAD du profil en priorit√© pour Enigma Scroll
    if (window.location.href.includes('enigma-scroll')) {
      console.log('üéÆ [Avatar] Jeu Enigma Scroll d√©tect√© - FORCE RELOAD du profil...');
      await this.forceReloadProfileForEnigmaScroll();
      
      // Attendre un peu pour que tout soit bien charg√©
      await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    // 3. Charger les donn√©es utilisateur
    await this.loadUserData();
    
    // 4. NOUVEAU: Cr√©er l'interface avatar DIRECTEMENT
    console.log('üé® [Avatar] Cr√©ation interface avatar...');
    this.createAvatarInterface();
    
    // 5. FORCE: Cr√©er aussi l'Ultra Adventurer pour les tests
    console.log('üèÉ‚Äç‚ôÇÔ∏è [Avatar] FORCE cr√©ation Ultra Adventurer...');
    setTimeout(() => {
      this.createUltraReactiveMiniAdventurer();
      
      // V√©rifier que l'avatar est cr√©√©
      setTimeout(() => {
        const avatar = document.getElementById('ultra-adventurer');
        if (avatar) {
          console.log('‚úÖ [Avatar] Ultra Adventurer cr√©√© avec succ√®s:', avatar);
          console.log('üìç [Avatar] Position:', avatar.getBoundingClientRect());
        } else {
          console.error('‚ùå [Avatar] Ultra Adventurer PAS cr√©√©!');
          // Retry imm√©diatement
          this.createUltraReactiveMiniAdventurer();
        }
      }, 1000);
    }, 500);
    
    // 6. D√©marrer les syst√®mes
    this.startEngagementTracking();
    this.setupGameDetection();
    
    console.log('‚úÖ [Avatar] Syst√®me avatar gaming initialis√©!');
    return this;
  }

  detectDeviceCapabilities() {
    // D√©tection avanc√©e des capacit√©s mobile
    this.deviceInfo = {
      isMobile: /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
      isTablet: /iPad|Android/i.test(navigator.userAgent) && window.innerWidth > 768,
      supportsTouch: 'ontouchstart' in window,
      screenSize: {
        width: window.innerWidth,
        height: window.innerHeight,
        ratio: window.devicePixelRatio || 1
      },
      connection: navigator.connection?.effectiveType || 'unknown',
      reducedMotion: window.matchMedia('(prefers-reduced-motion: reduce)').matches,
      highContrast: window.matchMedia('(prefers-contrast: high)').matches
    };
    
    // Ajuster les performances selon le device
    if (this.deviceInfo.isMobile && this.deviceInfo.connection === 'slow-2g') {
      this.performanceLevel = 'low';
    } else if (this.deviceInfo.isTablet) {
      this.performanceLevel = 'high';
    }
    
    console.log('üì± [Avatar] Device d√©tect√©:', this.deviceInfo);
  }

  createDemoUser() {
    console.log('üë§ [Avatar] Cr√©ation utilisateur d√©mo avec accessoire par d√©faut');
    this.currentUser = {
      username: 'Aventurier',
      level: 1,
      xp: 42,
      avatar: {
        head: 'default_boy',
        body: 'default_boy', 
        accessory: 'default', // Accessoire GIF par d√©faut
        background: 'forest'
      }
    };
    return this.currentUser;
  }

  async loadUserData() {
    try {
      console.log('üîç [Avatar] Chargement donn√©es utilisateur...');
      
      // Syst√®me de chargement multi-sources am√©lior√©
      const sources = [
        () => localStorage.getItem('english_quest_current_user'),
        () => localStorage.getItem('currentUser'),
        () => window.authService?.getCurrentUser?.(),
        () => window.authService?.currentUser
      ];
      
      for (const source of sources) {
        try {
          const userData = source();
          if (userData) {
            if (typeof userData === 'string') {
              this.currentUser = JSON.parse(userData);
            } else {
              this.currentUser = userData;
            }
            
            console.log('‚úÖ [Avatar] Donn√©es utilisateur brutes:', this.currentUser);
            
            // NOUVEAU: Force le rechargement du profil si on est dans Enigma Scroll
            if (window.location.pathname.includes('enigma-scroll')) {
              console.log('üéÆ [Avatar] Enigma Scroll d√©tect√© - rechargement FORC√â du profil...');
              await this.forceReloadProfileForEnigmaScroll();
            }
            
            // Charger l'√©quipement actuel depuis l'inventaire
            await this.loadEquippedItems();
            
            // Valider et normaliser les donn√©es avatar
            this.normalizeAvatarData();
            console.log('‚úÖ [Avatar] Avatar final:', this.currentUser.avatar);
            console.log('‚úÖ [Avatar] Utilisateur charg√©:', this.currentUser.username || 'Utilisateur');
            return;
          }
        } catch (e) {
          console.warn('‚ö†Ô∏è [Avatar] Erreur source utilisateur:', e);
        }
      }
      
      // Si aucune source ne fonctionne, cr√©er un utilisateur d√©mo
      console.warn('‚ö†Ô∏è [Avatar] Aucune donn√©e utilisateur trouv√©e, cr√©ation utilisateur d√©mo');
      this.createDemoUser();
      
    } catch (error) {
      console.error('‚ùå [Avatar] Erreur chargement utilisateur:', error);
      this.createDemoUser();
    }
  }

  async forceReloadProfileForEnigmaScroll() {
    if (!window.location.href.includes('enigma-scroll')) {
      return;
    }

    console.log('üîÑ [Avatar] FORCE RELOAD profile pour Enigma Scroll...');
    
    try {
      // 1. Nettoyer le cache existant
      this.avatarData = null;
      
      // 2. Essayer toutes les sources possibles
      let profileData = null;
      
      // SOURCE 1: authService (priorit√©)
      if (window.authService && typeof window.authService.getCurrentUser === 'function') {
        console.log('üì° [Avatar] Tentative authService...');
        try {
          const authUser = window.authService.getCurrentUser();
          if (authUser) {
            console.log('‚úÖ [Avatar] Utilisateur authService trouv√©:', authUser.username || authUser.displayName);
            
            // Charger le profil complet depuis authService
            if (window.authService.loadUserProfile) {
              profileData = await window.authService.loadUserProfile(authUser.uid);
              if (profileData) {
                console.log('‚úÖ [Avatar] Profil authService complet:', profileData);
              }
            } else {
              profileData = authUser;
            }
          }
        } catch (error) {
          console.warn('‚ö†Ô∏è [Avatar] Erreur authService:', error);
        }
      }
      
      // SOURCE 2: Firebase direct
      if (!profileData && typeof firebase !== 'undefined' && firebase.firestore) {
        console.log('üî• [Avatar] Tentative Firebase direct...');
        try {
          const userId = localStorage.getItem('englishQuestUserId') || 
                         localStorage.getItem('english_quest_current_user_id');
          
          if (userId && userId !== 'undefined' && userId !== 'null') {
            const db = firebase.firestore();
            const userDoc = await db.collection('users').doc(userId).get();
            
            if (userDoc.exists) {
              profileData = { uid: userId, ...userDoc.data() };
              console.log('‚úÖ [Avatar] Profil Firebase direct:', profileData);
            }
          }
        } catch (error) {
          console.warn('‚ö†Ô∏è [Avatar] Erreur Firebase direct:', error);
        }
      }
      
      // SOURCE 3: inventoryService
      if (!profileData && window.inventoryService) {
        console.log('üéí [Avatar] Tentative inventoryService...');
        try {
          const inventory = await window.inventoryService.getUserInventory();
          if (inventory && inventory.equipped) {
            profileData = {
              avatar: inventory.equipped,
              username: 'Joueur'
            };
            console.log('‚úÖ [Avatar] Profil inventoryService:', profileData);
          }
        } catch (error) {
          console.warn('‚ö†Ô∏è [Avatar] Erreur inventoryService:', error);
        }
      }
      
      // SOURCE 4: localStorage complet
      if (!profileData) {
        console.log('üíæ [Avatar] Scan localStorage complet...');
        const keys = [
          'english_quest_current_user',
          'currentUser',
          'englishQuestUserProfile',
          'userProfile',
          'enigmaScrollProfile'
        ];
        
        for (const key of keys) {
          try {
            const data = localStorage.getItem(key);
            if (data && data !== 'undefined' && data !== 'null') {
              const parsed = JSON.parse(data);
              if (parsed && (parsed.avatar || parsed.username || parsed.displayName)) {
                profileData = parsed;
                console.log(`‚úÖ [Avatar] Profil localStorage (${key}):`, profileData);
                break;
              }
            }
          } catch (e) {
            // Ignorer les erreurs de parsing
          }
        }
      }
      
      // 3. Appliquer les donn√©es trouv√©es
      if (profileData) {
        console.log('üé® [Avatar] Application profil trouv√©:', profileData);
        
        // Forcer la mise √† jour de l'avatar
        this.avatarData = {
          username: profileData.username || profileData.displayName || 'Joueur',
          level: profileData.level || 1,
          xp: profileData.xp || 0,
          avatar: profileData.avatar || {}
        };
        
        // Si l'avatar a des donn√©es mais pas la structure compl√®te
        if (profileData.avatar) {
          Object.assign(this.avatarData.avatar, profileData.avatar);
        }
        
        // Sauvegarder pour la prochaine fois
        localStorage.setItem('enigmaScrollProfile', JSON.stringify(this.avatarData));
        
        // Recr√©er l'avatar avec les nouvelles donn√©es
        this.recreateAvatar();
        
        console.log('‚úÖ [Avatar] Profil appliqu√© avec succ√®s!');
        return this.avatarData;
      } else {
        console.warn('‚ö†Ô∏è [Avatar] Aucun profil trouv√©, utilisation profil par d√©faut');
        this.avatarData = this.createDemoUser();
        return this.avatarData;
      }
      
    } catch (error) {
      console.error('‚ùå [Avatar] Erreur lors du force reload profile:', error);
      this.avatarData = this.createDemoUser();
      return this.avatarData;
    }
  }

  async loadEquippedItems() {
    try {
      console.log('üéí [Avatar] Tentative chargement √©quipement...');
      
      // M√âTHODE 1: V√©rifier dans les donn√©es utilisateur actuelles
      if (this.currentUser && this.currentUser.avatar) {
        console.log('üë§ [Avatar] Avatar existant dans currentUser:', this.currentUser.avatar);
        
        // Si l'avatar a des donn√©es, les garder
        if (this.currentUser.avatar.head || this.currentUser.avatar.body || this.currentUser.avatar.accessory) {
          console.log('‚úÖ [Avatar] Donn√©es avatar trouv√©es dans currentUser');
          return;
        }
      }
      
      // M√âTHODE 2: Charger depuis localStorage directement
      try {
        const profileData = localStorage.getItem('english_quest_current_user');
        if (profileData) {
          const userData = JSON.parse(profileData);
          console.log('üì¶ [Avatar] Donn√©es brutes localStorage:', userData);
          
          if (userData.avatar) {
            console.log('üé≠ [Avatar] Avatar trouv√© dans localStorage:', userData.avatar);
            this.currentUser.avatar = { ...userData.avatar };
            return;
          }
        }
      } catch (e) {
        console.warn('‚ö†Ô∏è [Avatar] Erreur lecture localStorage:', e);
      }
      
      // M√âTHODE 3: Service d'inventaire
      if (window.inventoryService && typeof window.inventoryService.getEquippedItems === 'function') {
        console.log('üéí [Avatar] Tentative via inventoryService...');
        const equippedItems = await window.inventoryService.getEquippedItems();
        
        if (equippedItems && Object.keys(equippedItems).length > 0) {
          console.log('‚úÖ [Avatar] √âquipement trouv√©:', equippedItems);
          
          // Mettre √† jour l'avatar avec les √©l√©ments √©quip√©s
          if (!this.currentUser.avatar) this.currentUser.avatar = {};
          
          if (equippedItems.head) {
            this.currentUser.avatar.head = equippedItems.head;
            console.log('üë§ [Avatar] T√™te √©quip√©e:', equippedItems.head);
          }
          if (equippedItems.body) {
            this.currentUser.avatar.body = equippedItems.body;
            console.log('üëï [Avatar] Corps √©quip√©:', equippedItems.body);
          }
          if (equippedItems.accessory) {
            this.currentUser.avatar.accessory = equippedItems.accessory;
            console.log('üé© [Avatar] Accessoire √©quip√©:', equippedItems.accessory);
          }
          if (equippedItems.background) {
            this.currentUser.avatar.background = equippedItems.background;
            console.log('üèûÔ∏è [Avatar] Arri√®re-plan √©quip√©:', equippedItems.background);
          }
          return;
        }
      }
      
      // M√âTHODE 4: Forcer un refresh depuis le profil
      console.log('üîÑ [Avatar] Tentative rechargement profil...');
      await this.forceProfileReload();
      
    } catch (error) {
      console.error('‚ùå [Avatar] Erreur chargement √©quipement:', error);
    }
  }

  async forceProfileReload() {
    try {
      // Essayer de r√©cup√©rer les donn√©es depuis l'API ou les services
      if (window.authService && window.authService.currentUser) {
        console.log('üîÑ [Avatar] Rechargement via authService...');
        const currentUser = window.authService.currentUser;
        
        if (currentUser.avatar) {
          console.log('‚úÖ [Avatar] Avatar trouv√© via authService:', currentUser.avatar);
          this.currentUser.avatar = { ...currentUser.avatar };
          return;
        }
      }
      
      // Essayer avec les donn√©es Firebase si disponible
      if (typeof firebase !== 'undefined' && firebase.auth && firebase.auth().currentUser) {
        console.log('üîÑ [Avatar] Tentative Firebase...');
        const uid = firebase.auth().currentUser.uid;
        const db = firebase.firestore();
        
        try {
          const doc = await db.collection('users').doc(uid).get();
          if (doc.exists) {
            const userData = doc.data();
            console.log('üìÑ [Avatar] Donn√©es Firebase r√©cup√©r√©es:', userData);
            
            if (userData.avatar) {
              console.log('‚úÖ [Avatar] Avatar trouv√© dans Firebase:', userData.avatar);
              this.currentUser.avatar = { ...userData.avatar };
              
              // Sauvegarder en localStorage pour la prochaine fois
              localStorage.setItem('english_quest_current_user', JSON.stringify(this.currentUser));
              return;
            }
          }
        } catch (firebaseError) {
          console.warn('‚ö†Ô∏è [Avatar] Erreur Firebase:', firebaseError);
        }
      }
      
      console.warn('‚ö†Ô∏è [Avatar] Impossible de recharger le profil, utilisation des d√©fauts');
    } catch (error) {
      console.error('‚ùå [Avatar] Erreur rechargement profil:', error);
    }
  }

  normalizeAvatarData() {
    if (!this.currentUser.avatar) {
      this.currentUser.avatar = {
        head: 'default_boy',
        body: 'default_boy',
        accessory: 'none',
        background: 'forest'
      };
    }
    
    // Assurer les valeurs par d√©faut
    const defaults = {
      head: 'default_boy',
      body: 'default_boy', 
      accessory: 'none',
      background: 'forest'
    };
    
    Object.keys(defaults).forEach(key => {
      if (!this.currentUser.avatar[key]) {
        this.currentUser.avatar[key] = defaults[key];
      }
    });
  }

  createAvatarInterface() {
    // Supprimer avatar existant
    const existing = document.querySelector('.game-mini-avatar');
    if (existing) existing.remove();
    
    // Cr√©er nouveau conteneur avec design mobile-first
    this.avatarContainer = document.createElement('div');
    this.avatarContainer.className = 'game-mini-avatar';
    this.avatarContainer.id = 'gameAvatarWidget';
    
    // Ajouter attributs d'accessibilit√©
    this.avatarContainer.setAttribute('role', 'complementary');
    this.avatarContainer.setAttribute('aria-label', 'Avatar du joueur et informations');
    this.avatarContainer.setAttribute('tabindex', '0');
    
    // G√©n√©rer le contenu HTML
    this.avatarContainer.innerHTML = this.generateMiniAvatarHTML();
    
    // D√©terminer la position selon le contexte
    this.positionAvatar();
    
    // Ajouter au DOM
    document.body.appendChild(this.avatarContainer);
    
    // Configuration sp√©ciale pour mobile
    if (this.deviceInfo.isMobile) {
      this.optimizeForMobile();
    }
    
    // D√©marrer les animations
    setTimeout(() => this.startIdleAnimations(), 1000);
  }

  positionAvatar() {
    const path = window.location.pathname;
    
    if (path.includes('/games/')) {
      // Position fixe pour les jeux
      this.avatarContainer.style.position = 'fixed';
      
      // Position adaptative selon la taille d'√©cran
      if (this.deviceInfo.isMobile) {
        this.avatarContainer.style.top = '15px';
        this.avatarContainer.style.right = '15px';
        this.avatarContainer.style.zIndex = '1500';
      } else {
        this.avatarContainer.style.top = '20px';
        this.avatarContainer.style.right = '20px';
        this.avatarContainer.style.zIndex = '1000';
      }
      
    } else if (path.includes('/courses/') || path.includes('/course/')) {
      // Mode int√©gr√© pour les cours
      this.avatarContainer.classList.add('lesson-mode');
      
      // Chercher un bon emplacement dans le contenu
      const courseContent = document.querySelector('.course-content, .lesson-content, main, .container');
      if (courseContent) {
        courseContent.insertBefore(this.avatarContainer, courseContent.firstChild);
        this.avatarContainer.style.position = 'relative';
      }
      
    } else {
      // Position par d√©faut
      this.avatarContainer.style.position = 'fixed';
      this.avatarContainer.style.top = '20px';
      this.avatarContainer.style.right = '20px';
    }
  }

  optimizeForMobile() {
    // Optimisations sp√©cifiques mobile
    this.avatarContainer.style.touchAction = 'manipulation';
    this.avatarContainer.style.webkitTapHighlightColor = 'transparent';
    
    // R√©duire les animations si connexion lente
    if (this.deviceInfo.connection === 'slow-2g' || this.performanceLevel === 'low') {
      this.avatarContainer.style.animationDuration = '0.1s';
      this.avatarContainer.style.transitionDuration = '0.1s';
    }
    
    // Ajuster la taille selon l'orientation
    const updateSize = () => {
      const isLandscape = window.innerWidth > window.innerHeight;
      if (isLandscape && window.innerWidth < 768) {
        this.avatarContainer.style.width = 'min(20vh, 100px)';
      } else {
        this.avatarContainer.style.width = 'min(25vw, 120px)';
      }
    };
    
    updateSize();
    window.addEventListener('orientationchange', updateSize);
    window.addEventListener('resize', updateSize);
  }

  setupMobileInteractions() {
    if (!this.avatarContainer) return;
    
    // Gestes tactiles avanc√©s
    this.avatarContainer.addEventListener('touchstart', (e) => {
      this.touchStartTime = Date.now();
      this.touchStartPos = {
        x: e.touches[0].clientX,
        y: e.touches[0].clientY
      };
    }, { passive: true });
    
    this.avatarContainer.addEventListener('touchend', (e) => {
      const touchDuration = Date.now() - this.touchStartTime;
      const touch = e.changedTouches[0];
      const distance = Math.sqrt(
        Math.pow(touch.clientX - this.touchStartPos.x, 2) +
        Math.pow(touch.clientY - this.touchStartPos.y, 2)
      );
      
      // Tap court = interaction normale
      if (touchDuration < 300 && distance < 10) {
        this.handleAvatarTap();
      }
      // Tap long = menu contexte (future feature)
      else if (touchDuration > 800 && distance < 10) {
        this.handleAvatarLongTap();
      }
      
    }, { passive: true });
    
    // Interactions clavier pour accessibilit√©
    this.avatarContainer.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        this.handleAvatarTap();
      }
    });
    
    // Hover pour desktop
    if (!this.deviceInfo.isMobile) {
      this.avatarContainer.addEventListener('mouseenter', () => {
        this.showQuickInfo();
      });
      
      this.avatarContainer.addEventListener('mouseleave', () => {
        this.hideQuickInfo();
      });
    }
  }

  handleAvatarTap() {
    console.log('üëÜ [Avatar] Interaction utilisateur');
    this.lastInteraction = Date.now();
    this.engagementLevel = Math.min(this.engagementLevel + 1, 10);
    
    // Effet visuel de tap
    this.avatarContainer.style.transform = 'scale(0.95)';
    setTimeout(() => {
      this.avatarContainer.style.transform = '';
    }, 150);
    
    // R√©action contextuelle
    const reactions = [
      'Salut ! üëã',
      'Comment √ßa va ? üòä',
      'Tu progresses bien ! üåü',
      'Continue comme √ßa ! üí™',
      'Tu es fantastique ! ‚ú®'
    ];
    
    const randomReaction = reactions[Math.floor(Math.random() * reactions.length)];
    this.showReaction(randomReaction, 'happy');
    
    // Animation sp√©ciale pour l'engagement
    this.triggerEmotion('happy');
  }

  handleAvatarLongTap() {
    console.log('üëÜüì± [Avatar] Long tap d√©tect√©');
    // Future: Menu contextuel avec options avatar
    this.showReaction('Menu bient√¥t disponible ! üîß', 'thinking');
  }

  generateMiniAvatarHTML() {
    const avatar = this.currentUser.avatar;
    const userName = this.currentUser.username || this.currentUser.displayName || 'Joueur';
    const level = this.currentUser.level || 1;
    const xp = this.currentUser.xp || 0;
    
    return `
      <div class="mini-avatar-display avatar-container">
        <img src="../assets/avatars/backgrounds/${avatar.background}.png" 
             alt="Background" 
             class="avatar-background"
             onerror="this.style.display='none'">
        <img src="../assets/avatars/bodies/${avatar.body}.png" 
             alt="Body" 
             class="avatar-body" 
             id="gameMiniAvatarBody"
             onerror="this.src='../assets/avatars/bodies/default_boy.png'">
        <img src="../assets/avatars/heads/${avatar.head}.png" 
             alt="Head" 
             class="avatar-head" 
             id="gameMiniAvatarHead"
             onerror="this.src='../assets/avatars/heads/default_boy.png'">
        <div class="avatar-accessory" id="gameMiniAvatarAccessory">
          <img src="../assets/avatars/accessories/${avatar.accessory}.gif" 
               alt="Accessory" 
               width="100%" 
               height="100%"
               onerror="this.style.display='none'">
        </div>
      </div>
      
      ${this.options.showXP ? `
        <div class="mini-avatar-info">
          <div class="mini-avatar-name">${userName}</div>
          <div class="mini-avatar-level">Niveau ${level}</div>
          <div class="mini-avatar-xp-bar">
            <div class="xp-fill" style="width: ${(xp % 100)}%"></div>
          </div>
        </div>
      ` : ''}
      
      <div class="mini-avatar-status">
        <div class="status-indicator idle">‚óè</div>
        <div class="reaction-text"></div>
      </div>
      
      ${this.deviceInfo.isMobile ? `
        <div class="mobile-engagement-indicator" style="
          position: absolute;
          top: -5px;
          left: -5px;
          width: 15px;
          height: 15px;
          background: linear-gradient(45deg, #2ecc71, #3498db);
          border-radius: 50%;
          opacity: 0;
          transform: scale(0);
          transition: all 0.3s ease;
        "></div>
      ` : ''}
    `;
  }

  // Syst√®me d'engagement pour mobile
  startEngagementTracking() {
    setInterval(() => {
      this.sessionTime++;
      
      // R√©duire l'engagement si pas d'interaction
      const timeSinceInteraction = Date.now() - this.lastInteraction;
      if (timeSinceInteraction > 30000) { // 30 secondes
        this.engagementLevel = Math.max(0, this.engagementLevel - 0.1);
      }
      
      // Encouragements selon l'engagement
      if (this.sessionTime % 120 === 0 && this.engagementLevel < 3) { // Chaque 2 minutes
        this.encourageUser();
      }
      
    }, 1000);
  }

  encourageUser() {
    const encouragements = [
      'Hey ! Tu es toujours l√† ? üëÄ',
      'Pr√™t pour un d√©fi ? üí™',
      'Ta progression est importante ! üìà',
      'Allez, encore un effort ! üåü',
      'Tu peux le faire ! üöÄ'
    ];
    
    const randomEncouragement = encouragements[Math.floor(Math.random() * encouragements.length)];
    this.showReaction(randomEncouragement, 'thinking');
    
    // Animation d'attention
    this.avatarContainer.style.animation = 'attention-pulse 1s ease-in-out 3';
  }

  // Syst√®me de d√©tection automatique des jeux
  setupGameDetection() {
    // D√©tecter Enigma Scroll SANS R√âCURSION
    if (window.location.pathname.includes('enigma-scroll')) {
      this.initEnigmaScrollIntegration();
      document.body.setAttribute('data-game', 'enigma-scroll');
    }
    
    // Autres jeux peuvent √™tre ajout√©s ici
    if (window.location.pathname.includes('speed-verb')) {
      document.body.setAttribute('data-game', 'speed-verb');
    }
    
    // Observer les changements de score g√©n√©riques
    this.observeScoreChanges();
  }

  initEnigmaScrollIntegration() {
    console.log('üéÆ [Avatar] Initialisation Enigma Scroll - VERSION ULTRA-CORRIG√âE');
    
    // Force restart fresh pour √©viter les boucles
    this.isEnigmaScrollInit = true;
    
    // Cr√©er l'avatar s'il n'existe pas
    if (!document.getElementById('ultra-adventurer')) {
      console.log('üèÉ‚Äç‚ôÇÔ∏è [Avatar] Avatar non trouv√©, cr√©ation imm√©diate...');
      this.createUltraReactiveMiniAdventurer();
    }
    
    // Attendre que l'avatar soit cr√©√© puis configurer les observateurs
    setTimeout(() => {
      // V√©rifier que l'avatar existe
      const adventurer = document.getElementById('ultra-adventurer');
      if (adventurer) {
        console.log('‚úÖ [Avatar] Avatar trouv√©, configuration des observateurs...');
        this.observeEnigmaScrollElements();
        
        // Test de l'avatar
        setTimeout(() => {
          this.showSpeechBubble('Avatar ready! Let\'s start the game!', 2500);
          this.triggerPhysicalAnimation('physicalHop');
          console.log('üéØ [Avatar] Test de l\'avatar effectu√©');
        }, 2000);
      } else {
        console.error('‚ùå [Avatar] Avatar toujours non trouv√© apr√®s cr√©ation');
        // Retry
        this.createUltraReactiveMiniAdventurer();
      }
    }, 1000);
    
    console.log('‚úÖ [Avatar] Enigma Scroll integration initialized');
  }

  setupSimpleEnigmaScrollMotivation() {
    // Observer les √©l√©ments de jeu sp√©cifiques SANS R√âCURSION
    this.observeEnigmaScrollElements();
    
    // Feedback simple
    this.startSimpleEnigmaScrollFeedback();
  }

  observeEnigmaScrollElements() {
    // Observer le score pour d√©clencher la motivation
    const scoreDisplay = document.getElementById('score-display');
    if (scoreDisplay) {
      this.previousScore = 0;
      
      const scoreObserver = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.type === 'childList' || mutation.type === 'characterData') {
            const newScore = parseInt(scoreDisplay.textContent) || 0;
            if (newScore > this.previousScore) {
              const scoreDiff = newScore - this.previousScore;
              this.handleScoreIncrease(scoreDiff, newScore);
            }
            this.previousScore = newScore;
          }
        });
      });
      
      scoreObserver.observe(scoreDisplay, {
        childList: true,
        subtree: true,
        characterData: true
      });
    }

    // Observer le combo
    const comboDisplay = document.getElementById('combo-display');
    if (comboDisplay) {
      const comboObserver = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.type === 'childList' || mutation.type === 'characterData') {
            const comboText = comboDisplay.textContent;
            const comboValue = parseInt(comboText.replace('x', '')) || 1;
            this.handleComboChange(comboValue);
          }
        });
      });
      
      comboObserver.observe(comboDisplay, {
        childList: true,
        subtree: true,
        characterData: true
      });
    }

    // Observer le temps
    const timeDisplay = document.getElementById('time-display');
    if (timeDisplay) {
      const timeObserver = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.type === 'childList' || mutation.type === 'characterData') {
            const timeLeft = parseInt(timeDisplay.textContent) || 0;
            this.handleTimeChange(timeLeft);
          }
        });
      });
      
      timeObserver.observe(timeDisplay, {
        childList: true,
        subtree: true,
        characterData: true
      });
    }

    // Observer les tentatives
    const attemptsDisplay = document.getElementById('attempts-display');
    if (attemptsDisplay) {
      const attemptsObserver = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.type === 'childList' || mutation.type === 'characterData') {
            const attemptsText = attemptsDisplay.textContent;
            const [current, max] = attemptsText.split('/').map(x => parseInt(x));
            this.handleAttemptsChange(current, max);
          }
        });
      });
      
      attemptsObserver.observe(attemptsDisplay, {
        childList: true,
        subtree: true,
        characterData: true
      });
    }
  }

  handleScoreIncrease(scoreDiff, totalScore) {
    console.log(`üìà [Avatar] Score augment√© de ${scoreDiff}, total: ${totalScore}`);
    
    const avatar = document.getElementById('ultra-adventurer');
    if (!avatar) return;
    
    if (scoreDiff >= 50) {
      this.showSpeechBubble(`EXCELLENT ! +${scoreDiff} points ! üî•`, 3000);
      this.triggerPhysicalAnimation('physicalVictoryDance');
      this.changeAura('victory', 4000);
    } else if (scoreDiff >= 20) {
      this.showSpeechBubble(`Bien jou√© ! +${scoreDiff} points ! üëè`, 2500);
      this.triggerPhysicalAnimation('physicalPump');
      this.changeAura('success', 3000);
    } else {
      this.showSpeechBubble(`+${scoreDiff} points ! Continue ! ‚≠ê`, 2000);
      this.triggerPhysicalAnimation('physicalHop');
    }
  }

  handleComboChange(comboValue) {
    console.log(`üî• [Avatar] Combo: x${comboValue}`);
    
    const avatar = document.getElementById('ultra-adventurer');
    if (!avatar) return;
    
    if (comboValue >= 5) {
      this.showSpeechBubble(`COMBO x${comboValue} ! TU ES EN FEU ! üî•üëë`, 4000);
      this.triggerPhysicalAnimation('physicalFireDance');
      this.changeAura('fire', 5000);
    } else if (comboValue >= 3) {
      this.showSpeechBubble(`Super combo x${comboValue} ! üí™‚ö°`, 3000);
      this.triggerPhysicalAnimation('physicalDance');
      this.changeAura('success', 3500);
    } else if (comboValue >= 2) {
      this.showSpeechBubble(`Combo x${comboValue} ! Maintiens le rythme ! üéØ`, 2500);
      this.triggerPhysicalAnimation('physicalClap');
    }
  }

  handleTimeChange(timeLeft) {
    const avatar = document.getElementById('ultra-adventurer');
    if (!avatar) return;
    
    if (timeLeft <= 10 && timeLeft > 0) {
      this.showSpeechBubble(`${timeLeft}s ! D√âP√äCHE-TOI ! ‚è∞üí®`, 2000);
      this.triggerPhysicalAnimation('physicalPanicWave');
      this.changeAura('fire', 2000);
    } else if (timeLeft <= 30) {
      this.showSpeechBubble(`Plus que ${timeLeft}s ! Concentre-toi ! üéØ`, 2500);
      this.triggerPhysicalAnimation('physicalTilt');
    }
  }

  handleAttemptsChange(current, max) {
    const avatar = document.getElementById('ultra-adventurer');
    if (!avatar) return;
    
    const remaining = max - current;
    
    if (remaining <= 1) {
      this.showSpeechBubble('DERNI√àRE CHANCE ! Donne tout ! üí™üî•', 3000);
      this.triggerPhysicalAnimation('physicalShake');
      this.changeAura('fire', 4000);
    } else if (remaining <= 2) {
      this.showSpeechBubble(`Plus que ${remaining} tentatives ! üéØ`, 2500);
      this.triggerPhysicalAnimation('physicalNod');
    }
  }

  startSimpleEnigmaScrollFeedback() {
    console.log('üí¨ [Avatar] D√©marrage feedback Enigma Scroll simple...');
    
    // Feedback p√©riodique simplifi√© pour maintenir l'engagement
    setInterval(() => {
      if (this.isGameActive()) {
        this.provideSimpleFeedback();
      }
    }, 20000); // Toutes les 20 secondes (moins fr√©quent)
  }

  provideSimpleFeedback() {
    const feedbackMessages = [
      "Continue comme √ßa ! üí™",
      "Tu fais du bon travail ! üëè", 
      "Reste concentr√© ! üéØ",
      "Excellent effort ! ‚≠ê",
      "Tu progresses bien ! üìà"
    ];
    
    const randomMessage = feedbackMessages[Math.floor(Math.random() * feedbackMessages.length)];
    this.showReaction(randomMessage, 'thinking', 3000);
  }

  providePereiodicFeedback() {
    const feedbacks = [
      'Tu progresses bien ! üåü',
      'Chaque mot compte ! üìö',
      'Ton niveau s\'am√©liore ! üìà',
      'Continue comme √ßa ! üí™',
      'Tu es sur la bonne voie ! üéØ'
    ];
    
    const randomFeedback = feedbacks[Math.floor(Math.random() * feedbacks.length)];
    this.updateMotivationalState('ready', { text: randomFeedback });
  }

  isGameActive() {
    const gameArea = document.getElementById('game-area');
    return gameArea && !gameArea.classList.contains('hidden');
  }

  observeGameProgress() {
    // Observer le score pour adapter l'√©tat √©motionnel
    const scoreElement = document.querySelector('#score-display');
    if (scoreElement) {
      let lastScore = parseInt(scoreElement.textContent) || 0;
      
      const observer = new MutationObserver(() => {
        const newScore = parseInt(scoreElement.textContent) || 0;
        if (newScore > lastScore) {
          const increase = newScore - lastScore;
          // Plus le gain est important, plus l'effort est r√©compens√©
          const effortLevel = Math.min(100, 30 + (increase * 2));
          
          if (this.updateBattleState) {
            this.updateBattleState('winning', { 
              text: `+${increase} points ! üéØ`, 
              effort: effortLevel,
              emotion: 'üî•'
            });
          }
        }
        lastScore = newScore;
      });
      
      observer.observe(scoreElement, { childList: true, characterData: true, subtree: true });
    }
    
    // Observer le combo pour l'√©tat √©motionnel
    const comboElement = document.querySelector('#combo-display');
    if (comboElement) {
      const observer = new MutationObserver(() => {
        const comboText = comboElement.textContent;
        const comboValue = parseInt(comboText.replace('x', '')) || 1;
        
        if (comboValue > 1 && this.updateBattleState) {
          const effortLevel = Math.min(100, 40 + (comboValue * 10));
          this.updateBattleState('winning', { 
            text: `Combo ${comboText} ! üî•`, 
            effort: effortLevel,
            emotion: 'üöÄ'
          });
        }
      });
      
      observer.observe(comboElement, { childList: true, characterData: true, subtree: true });
    }
    
    // Observer le temps pour l'urgence
    const timeElement = document.querySelector('#time-display');
    if (timeElement) {
      const observer = new MutationObserver(() => {
        const timeLeft = parseInt(timeElement.textContent) || 0;
        
        if (timeLeft < 20 && timeLeft > 0 && this.updateBattleState) {
          // Temps critique = effort maximum
          this.updateBattleState('struggling', { 
            text: `Plus que ${timeLeft}s ! ‚è∞`, 
            effort: 90,
            emotion: 'üò∞'
          });
        } else if (timeLeft > 60 && this.updateBattleState) {
          // Beaucoup de temps = √©tat d√©tendu
          this.updateBattleState('thinking', { 
            text: 'Prends ton temps... üòå', 
            effort: 20,
            emotion: 'üòå'
          });
        }
      });
      
      observer.observe(timeElement, { childList: true, characterData: true, subtree: true });
    }
  }

  observeScoreChanges() {
    // Observer les changements de score dans diff√©rents √©l√©ments
    const scoreElements = [
      '#score-display',
      '#words-found-stat',
      '#total-score-stat',
      '.score',
      '.points'
    ];
    
    scoreElements.forEach(selector => {
      const element = document.querySelector(selector);
      if (element) {
        let lastScore = parseInt(element.textContent) || 0;
        
        const observer = new MutationObserver(() => {
          const newScore = parseInt(element.textContent) || 0;
          if (newScore > lastScore) {
            const increase = newScore - lastScore;
            this.showReaction(`+${increase} points ! üéØ`, 'happy');
            this.triggerEmotion('happy');
          }
          lastScore = newScore;
        });
        
        observer.observe(element, { childList: true, characterData: true, subtree: true });
      }
    });
  }

  // Reste des m√©thodes... (identique mais optimis√©)
  showReaction(text, emotion = 'thinking', duration = 2500) {
    if (!this.options.showReactions) return;
    
    this.reactionQueue.push({ text, emotion, duration });
    
    if (!this.isReacting) {
      this.processReactionQueue();
    }
  }

  async processReactionQueue() {
    if (this.reactionQueue.length === 0) {
      this.isReacting = false;
      return;
    }
    
    this.isReacting = true;
    const { text, emotion, duration } = this.reactionQueue.shift();
    
    const reactionElement = this.avatarContainer?.querySelector('.reaction-text');
    const statusElement = this.avatarContainer?.querySelector('.status-indicator');
    
    if (reactionElement && statusElement) {
      // Afficher la r√©action
      reactionElement.textContent = text;
      reactionElement.classList.add('show');
      
      // Changer le statut
      statusElement.className = `status-indicator ${emotion}`;
      
      // Animation d'engagement mobile
      if (this.deviceInfo.isMobile) {
        const engagementIndicator = this.avatarContainer.querySelector('.mobile-engagement-indicator');
        if (engagementIndicator) {
          engagementIndicator.style.opacity = '1';
          engagementIndicator.style.transform = 'scale(1)';
          setTimeout(() => {
            engagementIndicator.style.opacity = '0';
            engagementIndicator.style.transform = 'scale(0)';
          }, 1000);
        }
      }
      
      // Masquer apr√®s d√©lai
      setTimeout(() => {
        reactionElement.classList.remove('show');
        statusElement.className = 'status-indicator idle';
        
        // Traiter la prochaine r√©action
        setTimeout(() => this.processReactionQueue(), 500);
      }, duration);
    }
  }

  triggerEmotion(emotion) {
    const head = document.getElementById('gameMiniAvatarHead');
    const body = document.getElementById('gameMiniAvatarBody');
    
    if (head && body) {
      // Animation selon l'√©motion
      switch(emotion) {
        case 'happy':
          head.style.animation = 'bounce 0.6s ease-in-out 2';
          break;
        case 'excited':
          body.style.animation = 'wobble 0.8s ease-in-out 2';
          break;
        case 'thinking':
          head.style.animation = 'tilt 1s ease-in-out 2';
          break;
        case 'sad':
          head.style.animation = 'droop 0.8s ease-in-out 1';
          break;
      }
      
      // Reset animation
      setTimeout(() => {
        head.style.animation = '';
        body.style.animation = '';
      }, 2000);
    }
  }

  triggerCelebration() {
    console.log('üéâ [Avatar] C√©l√©bration !');
    
    // Animation compl√®te de c√©l√©bration
    this.avatarContainer.style.animation = 'celebration-bounce 1.5s ease-in-out';
    
    // Effet sp√©cial mobile
    if (this.deviceInfo.isMobile && navigator.vibrate) {
      navigator.vibrate([100, 50, 100, 50, 200]);
    }
    
    setTimeout(() => {
      this.avatarContainer.style.animation = '';
    }, 1500);
  }

  startIdleAnimations() {
    if (this.performanceLevel === 'low' || this.deviceInfo.reducedMotion) return;
    
    // Animations subtiles en idle
    setInterval(() => {
      if (!this.isReacting && Math.random() < 0.3) {
        const head = document.getElementById('gameMiniAvatarHead');
        if (head) {
          head.style.animation = 'idle-blink 0.3s ease-in-out';
          setTimeout(() => head.style.animation = '', 300);
        }
      }
    }, 8000);
  }

  // M√©thodes publiques pour int√©gration externe
  updateUserData(userData) {
    this.currentUser = { ...this.currentUser, ...userData };
    this.normalizeAvatarData();
    
    if (this.avatarContainer) {
      this.avatarContainer.innerHTML = this.generateMiniAvatarHTML();
      this.setupMobileInteractions();
    }
  }

  showCustomMessage(message, emotion = 'thinking') {
    this.showReaction(message, emotion);
  }

  celebrate() {
    this.triggerCelebration();
  }

  setPerformanceMode(mode) {
    this.performanceLevel = mode;
    if (mode === 'low') {
      // D√©sactiver les animations co√ªteuses
      this.avatarContainer.style.animationDuration = '0.1s';
    }
  }

  // NOUVEAU: Cr√©er directement le Mini Aventurier ultra-r√©actif
  createIntegratedAvatarComponents() {
    // Supprimer les anciens avatars
    this.removeOldAvatars();
    
    // Cr√©er directement le Mini Aventurier
    this.createUltraReactiveMiniAdventurer();
  }

  removeOldAvatars() {
    // Supprimer tous les anciens avatars
    const oldAvatars = document.querySelectorAll('.game-mini-avatar, .avatar-motivational-center, .avatar-learning-motivator, .avatar-game-battle, .avatar-learning-buddy, .wandering-pet-avatar, .floating-buddy-avatar, .corner-assistant-avatar, .mini-adventurer-avatar');
    oldAvatars.forEach(avatar => avatar.remove());
  }

  createUltraReactiveMiniAdventurer() {
    if (document.getElementById('ultra-adventurer')) {
      // Supprimer l'ancien avatar pour le recr√©er avec les bonnes donn√©es
      console.log('üîÑ [Avatar] Avatar existant trouv√©, suppression pour recr√©ation...');
      document.getElementById('ultra-adventurer').remove();
    }
    
    console.log('üèÉ‚Äç‚ôÇÔ∏è Cr√©ation Mini Adventurer ULTRA-R√âACTIF avec profil:', this.currentUser?.avatar);
    
    // NOUVEAU: Forcer le rechargement des donn√©es utilisateur avant cr√©ation
    this.forceReloadUserDataSync();
    
    // Cr√©er le container principal
    const adventurerContainer = document.createElement('div');
    adventurerContainer.className = 'ultra-reactive-adventurer';
    adventurerContainer.id = 'ultra-adventurer';
    adventurerContainer.innerHTML = `
      <div class="adventurer-avatar-ultra">
        ${this.generateAvatarDisplayHTML()}
      </div>
      <div class="adventure-effects-ultra" id="adventureEffectsUltra"></div>
      <div class="adventure-speech-bubble" id="adventureSpeech" style="display: none;"></div>
      <div class="adventure-aura" id="adventureAura"></div>
    `;
    
    // Forcer le positionnement visible
    adventurerContainer.style.position = 'fixed';
    adventurerContainer.style.top = '100px';
    adventurerContainer.style.right = '30px';
    adventurerContainer.style.zIndex = '1200';
    adventurerContainer.style.opacity = '1';
    adventurerContainer.style.visibility = 'visible';
    adventurerContainer.style.display = 'block';
    
    document.body.appendChild(adventurerContainer);
    
    // Marquer comme visible
    this.isVisible = true;
    
    // D√©marrer les comportements
    this.startUltraReactiveBehavior();
    
    console.log('‚úÖ Ultra-Reactive Mini Adventurer cr√©√© avec succ√®s et positionn√© !');
    
    // NOUVEAU: V√©rifier apr√®s 2 secondes que l'avatar est bien visible
    setTimeout(() => {
      this.verifyAvatarVisibility();
    }, 2000);
  }

  // NOUVELLE FONCTION: Rechargement synchrone des donn√©es utilisateur
  forceReloadUserDataSync() {
    console.log('üîÑ [Avatar] Force reload synchrone des donn√©es utilisateur...');
    
    // Essayer toutes les sources possibles dans l'ordre de priorit√©
    const sources = [
      {
        name: 'english_quest_current_user',
        getData: () => {
          const data = localStorage.getItem('english_quest_current_user');
          return data ? JSON.parse(data) : null;
        }
      },
      {
        name: 'currentUser', 
        getData: () => {
          const data = localStorage.getItem('currentUser');
          return data ? JSON.parse(data) : null;
        }
      },
      {
        name: 'authService',
        getData: () => {
          return window.authService?.getCurrentUser?.();
        }
      },
      {
        name: 'enigmaScrollProfile',
        getData: () => {
          const data = localStorage.getItem('enigmaScrollProfile');
          return data ? JSON.parse(data) : null;
        }
      }
    ];
    
    for (const source of sources) {
      try {
        const userData = source.getData();
        if (userData && (userData.avatar || userData.username || userData.displayName)) {
          console.log(`‚úÖ [Avatar] Donn√©es trouv√©es via ${source.name}:`, userData);
          
          // Mettre √† jour this.currentUser avec les donn√©es compl√®tes
          this.currentUser = {
            username: userData.username || userData.displayName || 'Joueur',
            level: userData.level || 1,
            xp: userData.xp || 0,
            avatar: userData.avatar || {
              head: 'default_boy',
              body: 'default_boy',
              accessory: 'default',
              background: 'forest'
            }
          };
          
          console.log('üé® [Avatar] Donn√©es utilisateur mises √† jour:', this.currentUser);
          return true;
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è [Avatar] Erreur avec source ${source.name}:`, error);
      }
    }
    
    console.warn('‚ö†Ô∏è [Avatar] Aucune donn√©e utilisateur trouv√©e, utilisation profil par d√©faut');
    this.currentUser = this.createDemoUser();
    return false;
  }

  verifyAvatarVisibility() {
    const adventurer = document.getElementById('ultra-adventurer');
    if (!adventurer) {
      console.error('‚ùå [Avatar] Avatar non trouv√© apr√®s cr√©ation ! Recr√©ation...');
      this.createUltraReactiveMiniAdventurer();
      return;
    }
    
    const rect = adventurer.getBoundingClientRect();
    if (rect.width === 0 || rect.height === 0) {
      console.warn('‚ö†Ô∏è [Avatar] Avatar invisible apr√®s cr√©ation ! Correction...');
      this.forceAvatarVisibility(adventurer);
    } else {
      console.log('‚úÖ [Avatar] Avatar v√©rifi√© et visible:', {
        width: rect.width,
        height: rect.height,
        top: rect.top,
        left: rect.left
      });
    }
  }

  generateAvatarDisplayHTML() {
    // NOUVELLE M√âTHODE: Essayer de recharger les donn√©es utilisateur √† la vol√©e
    let user = this.currentUser;
    
    // Si pas de donn√©es utilisateur ou donn√©es par d√©faut, essayer de recharger
    if (!user || !user.avatar || user.username === 'Aventurier') {
      console.log('üîÑ [Avatar] Rechargement donn√©es utilisateur pour HTML...');
      
      // Essayer plusieurs sources de donn√©es
      const sources = [
        () => {
          const data = localStorage.getItem('english_quest_current_user');
          return data ? JSON.parse(data) : null;
        },
        () => {
          const data = localStorage.getItem('currentUser');
          return data ? JSON.parse(data) : null;
        },
        () => {
          return window.authService?.getCurrentUser?.();
        },
        () => {
          const data = localStorage.getItem('enigmaScrollProfile');
          return data ? JSON.parse(data) : null;
        }
      ];
      
      for (const source of sources) {
        try {
          const userData = source();
          if (userData && (userData.avatar || userData.username)) {
            console.log('‚úÖ [Avatar] Donn√©es utilisateur trouv√©es pour HTML:', userData);
            user = userData;
            this.currentUser = userData; // Mettre √† jour aussi l'instance
            break;
          }
        } catch (e) {
          // Ignorer les erreurs
        }
      }
    }
    
    // Si toujours pas de donn√©es, utiliser le profil par d√©faut mais avec log
    if (!user) {
      console.warn('‚ö†Ô∏è [Avatar] Aucune donn√©e utilisateur trouv√©e, utilisation profil d√©mo');
      user = this.createDemoUser();
    }
    
    const avatar = user.avatar || {};
    
    console.log('üé® [Avatar] G√©n√©ration HTML avec avatar:', avatar);
    console.log('üë§ [Avatar] Utilisateur:', user.username || user.displayName || 'Inconnu');
    
    // Construire les chemins d'images correctement
    const getAvatarPath = (type, value) => {
      if (!value || value === 'none') return null;
      // Si c'est d√©j√† un chemin complet, l'utiliser tel quel
      if (value.includes('/') || value.includes('.')) {
        return value;
      }
      
      // CORRECTION CRITIQUE: bodies au lieu de bodys
      if (type === 'body') {
        return `../assets/avatars/bodies/${value}.png`;
      }
      
      // Pour les autres types (head, accessory, etc.)
      return `../assets/avatars/${type}s/${value}.png`;
    };
    
    const bodyPath = getAvatarPath('body', avatar.body) || '../assets/avatars/bodies/default_boy.png';
    const headPath = getAvatarPath('head', avatar.head) || '../assets/avatars/heads/default_boy.png';
    
    console.log('üñºÔ∏è [Avatar] Chemins images CORRIG√âS:');
    console.log('  - Corps:', bodyPath);
    console.log('  - T√™te:', headPath);
    console.log('  - Accessoire:', avatar.accessory);
    
    // Logique d'accessoire EXACTE du profil
    let accessoryHTML = '';
    console.log('[Avatar] Accessoire dans donn√©es:', avatar.accessory);
    
    if (avatar.accessory === 'default') {
      // Accessoire par d√©faut = GIF anim√©
      console.log('[Avatar] Affichage accessoire par d√©faut (GIF)');
      accessoryHTML = `
        <div class="avatar-accessory-ultra">
          <img src="../assets/avatars/accessories/default.gif" 
               alt="Animated Accessory" 
               style="width: 100%; height: 100%; display: block; object-fit: contain; opacity: 1;"
               onerror="console.warn('[Avatar] GIF √©chou√©, fallback PNG'); this.src='../assets/avatars/accessories/default.png';"
               onload="console.log('[Avatar] Accessoire GIF charg√© avec succ√®s');">
        </div>`;
    } else if (avatar.accessory && avatar.accessory !== 'none') {
      // Autre accessoire
      console.log('[Avatar] Affichage autre accessoire:', avatar.accessory);
      accessoryHTML = `
        <div class="avatar-accessory-ultra">
          <img src="${getAvatarPath('accessory', avatar.accessory)}" 
               alt="Accessory" 
               style="width: 100%; height: 100%; display: block; object-fit: contain; opacity: 1;"
               onerror="console.warn('[Avatar] Accessoire √©chou√©:', this.src); this.style.display='none';"
               onload="console.log('[Avatar] Accessoire charg√©:', this.src);">
        </div>`;
    }
    
    const finalHTML = `
      <div class="avatar-display-ultra">
        <!-- Corps -->
        <img src="${bodyPath}" 
             alt="Avatar Body" 
             class="avatar-body-ultra"
             onerror="this.src='../assets/avatars/bodies/default_boy.png'; console.warn('[Avatar] Corps √©chou√©:', this.src);"
             onload="console.log('[Avatar] Corps charg√©:', this.src);">
        
        <!-- T√™te COLL√âE au corps -->
        <img src="${headPath}" 
             alt="Avatar Head" 
             class="avatar-head-ultra"
             onerror="this.src='../assets/avatars/heads/default_boy.png'; console.warn('[Avatar] T√™te √©chou√©e:', this.src);"
             onload="console.log('[Avatar] T√™te charg√©e:', this.src);">
        
        <!-- Accessoire GIF -->
        ${accessoryHTML}
      </div>
    `;
    
    console.log('‚úÖ [Avatar] HTML g√©n√©r√© avec succ√®s');
    return finalHTML;
  }

  startUltraReactiveBehavior() {
    console.log('üéÆ [Avatar] D√©marrage comportement ultra-r√©actif...');
    
    // D√©marrer l'animation idle
    this.startIdleAnimations();
    
    // D√©marrer le watchdog de visibilit√©
    this.startVisibilityWatchdog();
    
    // D√©marrer les r√©actions de jeu
    this.setupUltraGameReactions();
    
    // NOUVEAU: D√©marrer le syst√®me de mouvement intelligent
    this.startIntelligentMovement();
    
    // Observer l'√©tat du jeu
    this.setupUltraGameObservers();
    
    console.log('‚úÖ [Avatar] Comportement ultra-r√©actif actif');
  }

  // NOUVEAU: Syst√®me de mouvement intelligent
  startIntelligentMovement() {
    console.log('üö∂‚Äç‚ôÇÔ∏è [Avatar] D√©marrage mouvement intelligent...');
    
    this.movementTimer = null;
    this.currentPosition = 'safe-top-right'; // Position par d√©faut
    this.lastGameActivity = Date.now();
    this.isMoving = false;
    
    // Positions s√ªres selon le jeu
    this.safePositions = {
      'enigma-scroll': [
        'safe-top-right',    // Position par d√©faut - ne g√™ne pas les mots
        'safe-bottom-right', // En bas √† droite - loin du clavier
        'safe-center-right'  // Milieu droite - neutre
      ],
      'default': [
        'safe-top-right',
        'safe-bottom-right',
        'safe-top-left',
        'safe-center-right'
      ]
    };
    
    // Surveiller l'activit√© du jeu
    this.observeGameActivity();
    
    // Premier mouvement apr√®s 10 secondes d'inactivit√©
    setTimeout(() => {
      this.scheduleNextMovement();
    }, 10000);
  }

  observeGameActivity() {
    // Surveiller les interactions utilisateur
    const activityEvents = ['click', 'keydown', 'touchstart', 'mousemove'];
    
    activityEvents.forEach(event => {
      document.addEventListener(event, () => {
        this.lastGameActivity = Date.now();
        
        // Si l'avatar est en mouvement pendant l'activit√©, l'arr√™ter
        if (this.isMoving) {
          this.pauseMovement();
        }
      }, { passive: true });
    });
  }

  scheduleNextMovement() {
    if (this.movementTimer) {
      clearTimeout(this.movementTimer);
    }
    
    // Attendre 15-30 secondes d'inactivit√© avant de bouger
    const inactivityDelay = 15000 + Math.random() * 15000;
    
    this.movementTimer = setTimeout(() => {
      this.checkAndMove();
    }, inactivityDelay);
  }

  checkAndMove() {
    const timeSinceActivity = Date.now() - this.lastGameActivity;
    
    // Ne bouger que si pas d'activit√© r√©cente (5 secondes minimum)
    if (timeSinceActivity < 5000) {
      console.log('üö∂‚Äç‚ôÇÔ∏è [Avatar] Activit√© r√©cente d√©tect√©e, report du mouvement');
      this.scheduleNextMovement();
      return;
    }
    
    // V√©rifier si le jeu est actif
    if (this.isGameActiveNow()) {
      console.log('üö∂‚Äç‚ôÇÔ∏è [Avatar] Jeu actif, report du mouvement');
      this.scheduleNextMovement();
      return;
    }
    
    this.moveToRandomSafePosition();
  }

  isGameActiveNow() {
    // V√©rifier si Enigma Scroll est en cours
    const gameStatus = document.querySelector('#gameStatus')?.textContent;
    const timeLeft = document.querySelector('#timeLeft')?.textContent;
    
    if (gameStatus && gameStatus.includes('en cours')) {
      return true;
    }
    
    if (timeLeft && parseInt(timeLeft) > 0) {
      return true;
    }
    
    // V√©rifier s'il y a des lettres s√©lectionn√©es
    const selectedLetters = document.querySelectorAll('.letter.selected');
    if (selectedLetters.length > 0) {
      return true;
    }
    
    return false;
  }

  moveToRandomSafePosition() {
    const avatar = document.getElementById('ultra-adventurer');
    if (!avatar) return;
    
    console.log('üö∂‚Äç‚ôÇÔ∏è [Avatar] D√©marrage mouvement doux...');
    
    // D√©terminer les positions s√ªres selon le jeu
    const gameType = window.location.href.includes('enigma-scroll') ? 'enigma-scroll' : 'default';
    const positions = this.safePositions[gameType];
    
    // Choisir une position diff√©rente de la actuelle
    const availablePositions = positions.filter(pos => pos !== this.currentPosition);
    const newPosition = availablePositions[Math.floor(Math.random() * availablePositions.length)];
    
    // Marquer comme en mouvement
    this.isMoving = true;
    avatar.classList.add('moving');
    
    // Changer de position
    avatar.classList.remove(this.currentPosition);
    avatar.classList.add(newPosition);
    this.currentPosition = newPosition;
    
    console.log(`üö∂‚Äç‚ôÇÔ∏è [Avatar] Mouvement vers: ${newPosition}`);
    
    // Arr√™ter l'√©tat "en mouvement" apr√®s la transition
    setTimeout(() => {
      avatar.classList.remove('moving');
      avatar.classList.add('idle-breathing');
      this.isMoving = false;
      
      // Programmer le prochain mouvement
      this.scheduleNextMovement();
    }, 4000); // Dur√©e de la transition CSS
  }

  pauseMovement() {
    const avatar = document.getElementById('ultra-adventurer');
    if (!avatar) return;
    
    avatar.classList.remove('moving');
    this.isMoving = false;
    
    if (this.movementTimer) {
      clearTimeout(this.movementTimer);
    }
    
    // Reprogrammer le mouvement apr√®s un d√©lai
    setTimeout(() => {
      this.scheduleNextMovement();
    }, 10000);
  }

  startVisibilityWatchdog() {
    console.log('üëÅÔ∏è [Avatar] D√©marrage surveillance visibilit√© RENFORC√âE...');
    
    // V√©rifier toutes les 3 secondes (plus fr√©quent) si l'avatar est visible
    this.visibilityTimer = setInterval(() => {
      const adventurer = document.getElementById('ultra-adventurer');
      if (!adventurer) {
        console.warn('‚ö†Ô∏è [Avatar] Avatar disparu ! Recr√©ation imm√©diate...');
        this.recreateAvatar();
        return;
      }
      
      // V√©rifier si l'avatar est r√©ellement visible
      const rect = adventurer.getBoundingClientRect();
      const isVisible = rect.width > 0 && rect.height > 0 && 
                       adventurer.style.display !== 'none' &&
                       adventurer.style.visibility !== 'hidden' &&
                       parseFloat(adventurer.style.opacity) !== 0;
      
      if (!isVisible) {
        console.warn('‚ö†Ô∏è [Avatar] Avatar invisible ! Restauration forc√©e...');
        this.forceAvatarVisibility(adventurer);
      }
      
      // V√©rifier la position STRICTEMENT (√©viter qu'il soit hors √©cran)
      const isOutOfBounds = rect.left < -50 || rect.top < 0 || 
                           rect.right > window.innerWidth + 50 || 
                           rect.bottom > window.innerHeight + 50;
      
      if (isOutOfBounds) {
        console.warn('‚ö†Ô∏è [Avatar] Avatar hors limites ! Repositionnement s√©curis√©...', {
          left: rect.left,
          top: rect.top,
          right: rect.right,
          bottom: rect.bottom,
          windowWidth: window.innerWidth,
          windowHeight: window.innerHeight
        });
        this.repositionAvatarSafely(adventurer);
      }
      
      // NOUVEAU: V√©rifier que l'avatar n'est pas bloqu√© dans une animation fig√©e
      const computedStyle = window.getComputedStyle(adventurer);
      if (computedStyle.transform === 'none' && computedStyle.animation === 'none') {
        // L'avatar semble fig√©, lui donner une animation d'idle
        this.restartIdleAnimation(adventurer);
      }
      
    }, 3000); // Toutes les 3 secondes
  }

  forceAvatarVisibility(adventurer) {
    console.log('üëÅÔ∏è [Avatar] FORCE visibilit√© compl√®te...');
    
    // Forcer ABSOLUMENT la visibilit√©
    adventurer.style.display = 'block !important';
    adventurer.style.visibility = 'visible !important';
    adventurer.style.opacity = '1 !important';
    adventurer.style.zIndex = '1200 !important';
    adventurer.style.pointerEvents = 'auto';
    
    // V√©rifier que toutes les classes CSS sont pr√©sentes
    if (!adventurer.classList.contains('ultra-reactive-adventurer')) {
      adventurer.classList.add('ultra-reactive-adventurer');
    }
    
    // Animation de r√©apparition spectaculaire
    adventurer.style.animation = 'fadeInAvatar 1s ease-in-out';
    
    // Ajouter une aura temporaire pour signaler la correction
    const tempAura = document.createElement('div');
    tempAura.style.cssText = `
      position: absolute;
      top: -10px;
      left: -10px;
      right: -10px;
      bottom: -10px;
      border: 2px solid #00ff00;
      border-radius: 50%;
      animation: visibilityAlert 2s ease-in-out;
      pointer-events: none;
      z-index: 1199;
    `;
    adventurer.appendChild(tempAura);
    
    setTimeout(() => {
      if (tempAura.parentNode) {
        tempAura.remove();
      }
    }, 2000);
    
    console.log('‚úÖ [Avatar] Visibilit√© FORC√âE avec succ√®s');
  }

  restartIdleAnimation(adventurer) {
    console.log('üí§ [Avatar] Red√©marrage animation idle...');
    
    const avatarDisplay = adventurer.querySelector('.adventurer-avatar-ultra');
    if (avatarDisplay) {
      // Supprimer l'animation actuelle
      avatarDisplay.style.animation = 'none';
      
      // Forcer un reflow
      avatarDisplay.offsetHeight;
      
      // Red√©marrer l'animation idle
      avatarDisplay.style.animation = 'adventurerIdle 4s ease-in-out infinite';
    }
  }

  recreateAvatar() {
    console.log('üîÑ [Avatar] Recr√©ation avatar...');
    
    // Supprimer l'ancien s'il existe
    const oldAvatar = document.getElementById('ultra-adventurer');
    if (oldAvatar) {
      oldAvatar.remove();
    }
    
    // Recr√©er l'avatar
    this.createUltraReactiveMiniAdventurer();
    
    // Red√©marrer les observateurs
    setTimeout(() => {
      this.setupUltraGameObservers();
      console.log('‚úÖ [Avatar] Avatar recr√©√© avec succ√®s');
    }, 500);
  }

  repositionAvatarSafely(adventurer) {
    console.log('üìç [Avatar] Repositionnement s√©curis√©...');
    
    // Position de secours au centre droit
    adventurer.style.position = 'fixed';
    adventurer.style.top = '30%';
    adventurer.style.right = '20px';
    adventurer.style.left = 'auto';
    adventurer.style.bottom = 'auto';
    adventurer.style.transform = 'none';
    
    // Animation de glissement vers la nouvelle position
    adventurer.style.transition = 'all 1s ease-in-out';
    
    console.log('‚úÖ [Avatar] Avatar repositionn√© en s√©curit√©');
  }

  // Am√©liorer isGameActive pour plus de robustesse
  isGameActive() {
    // V√©rifications multiples pour s'assurer que le jeu est actif
    const gameArea = document.getElementById('game-area');
    const welcomeScreen = document.getElementById('welcome-screen');
    
    // Le jeu est actif si game-area est visible et welcome-screen est cach√©
    const gameAreaVisible = gameArea && !gameArea.classList.contains('hidden') && 
                           gameArea.style.display !== 'none';
    const welcomeHidden = welcomeScreen && (welcomeScreen.classList.contains('hidden') || 
                         welcomeScreen.style.display === 'none');
    
    // V√©rifier aussi s'il y a une grille active
    const wordGrid = document.getElementById('word-grid') || document.querySelector('.word-grid');
    const hasActiveGrid = wordGrid && wordGrid.children.length > 0;
    
    const isActive = gameAreaVisible && welcomeHidden && hasActiveGrid;
    
    if (!isActive) {
      console.log('‚ÑπÔ∏è [Avatar] Jeu inactif - gameArea:', gameAreaVisible, 'welcomeHidden:', welcomeHidden, 'hasGrid:', hasActiveGrid);
    }
    
    return isActive;
  }

  setupUltraGameReactions() {
    const path = window.location.pathname;
    
    if (path.includes('/games/')) {
      this.setupUltraGameObservers();
    } else if (path.includes('/courses/')) {
      this.setupUltraCourseObservers();
    }
  }

  setupUltraGameObservers() {
    console.log('üéÆ [Avatar] Configuration observations ultra-r√©actives');
    
    // 1. Observer le SCORE
    this.observeScore();
    
    // 2. Observer le COMBO
    this.observeCombo();
    
    // 3. Observer le TEMPS
    this.observeTime();
    
    // 4. Observer les TENTATIVES
    this.observeAttempts();
    
    // 5. Observer les MESSAGES popup
    this.observeMessages();
    
    // 6. Observer les LETTRES tap√©es
    this.observeLetters();
    
    // 7. Observer les POWER-UPS
    this.observePowerUps();
    
    // 8. Observer l'√©tat du JEU
    this.observeGameState();
  }

  observeScore() {
    const scoreDisplay = document.getElementById('score-display');
    if (!scoreDisplay) return;
    
    this.previousScore = 0;
    
    const scoreObserver = new MutationObserver(() => {
      const newScore = parseInt(scoreDisplay.textContent) || 0;
      const scoreDiff = newScore - this.previousScore;
      
      if (scoreDiff > 0) {
        this.triggerAdventureReaction('scoreSmallGain', { 
          amount: scoreDiff, 
          total: newScore,
          isSmall: scoreDiff < 20,
          isMedium: scoreDiff >= 20 && scoreDiff < 50,
          isBig: scoreDiff >= 50
        });
      }
      
      this.previousScore = newScore;
    });
    
    scoreObserver.observe(scoreDisplay, { childList: true, subtree: true, characterData: true });
  }

  observeCombo() {
    const comboDisplay = document.getElementById('combo-display');
    if (!comboDisplay) return;
    
    this.previousCombo = 1;
    
    const comboObserver = new MutationObserver(() => {
      const comboText = comboDisplay.textContent;
      const newCombo = parseInt(comboText.replace('x', '')) || 1;
      
      if (newCombo > this.previousCombo) {
        this.triggerAdventureReaction('combo', { 
          combo: newCombo,
          isStreak: newCombo >= 3,
          isFire: newCombo >= 5
        });
      } else if (newCombo < this.previousCombo) {
        this.triggerAdventureReaction('comboBroken', { previousCombo: this.previousCombo });
      }
      
      this.previousCombo = newCombo;
    });
    
    comboObserver.observe(comboDisplay, { childList: true, subtree: true, characterData: true });
  }

  observeTime() {
    const timeDisplay = document.getElementById('time-display');
    if (!timeDisplay) return;
    
    const timeObserver = new MutationObserver(() => {
      const timeLeft = parseInt(timeDisplay.textContent) || 0;
      
      if (timeLeft <= 10 && timeLeft > 0) {
        this.triggerAdventureReaction('timeRunningOut', { timeLeft });
      } else if (timeLeft <= 30 && timeLeft > 10) {
        this.triggerAdventureReaction('timeLow', { timeLeft });
      }
    });
    
    timeObserver.observe(timeDisplay, { childList: true, subtree: true, characterData: true });
  }

  observeAttempts() {
    const attemptsDisplay = document.getElementById('attempts-display');
    if (!attemptsDisplay) return;
    
    const attemptsObserver = new MutationObserver(() => {
      const attemptsText = attemptsDisplay.textContent;
      const [current, max] = attemptsText.split('/').map(n => parseInt(n));
      
      if (current >= max - 1) {
        this.triggerAdventureReaction('attemptFailed', { current, max });
      } else if (current >= max - 2) {
        this.triggerAdventureReaction('pressureMounting', { current, max });
      }
    });
    
    attemptsObserver.observe(attemptsDisplay, { childList: true, subtree: true, characterData: true });
  }

  observeMessages() {
    const gameObserver = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.addedNodes.length > 0) {
          mutation.addedNodes.forEach(node => {
            if (node.nodeType === 1 && node.classList?.contains('popup-message')) {
              const message = node.textContent.toLowerCase();
              
              if (message.includes('f√©licitations') || message.includes('bravo')) {
                this.triggerAdventureReaction('victory', { message });
              } else if (message.includes('√©coul√©') || message.includes('perdu')) {
                this.triggerAdventureReaction('defeat', { message });
              } else if (message.includes('invalide')) {
                this.triggerAdventureReaction('wrongWord', { message });
              } else if (message.includes('incomplet')) {
                this.triggerAdventureReaction('incomplete', { message });
              } else if (message.includes('nouveau mot')) {
                this.triggerAdventureReaction('newWord', { message });
              }
            }
          });
        }
      });
    });
    
    gameObserver.observe(document.body, { childList: true, subtree: true });
  }

  observeLetters() {
    if (this.letterObserver) {
      this.letterObserver.disconnect();
    }

    console.log('üî§ [Avatar] Configuration observateur VALIDATIONS (pas lettres individuelles)...');
    
    // Observer SEULEMENT les validations de mots et r√©sultats importants
    const wordGrid = document.getElementById('word-grid') || document.querySelector('.word-grid');
    if (!wordGrid) {
      console.warn('‚ö†Ô∏è [Avatar] Grille de mots non trouv√©e');
      return;
    }

    this.letterObserver = new MutationObserver((mutations) => {
      mutations.forEach(mutation => {
        // Observer seulement les changements de classes (correct, present, absent)
        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
          const cell = mutation.target;
          if (cell.classList.contains('grid-cell')) {
            
            // V√©rifier si c'est la fin d'une validation (toute la ligne a des classes)
            const row = cell.getAttribute('data-row');
            if (row !== null) {
              const rowCells = document.querySelectorAll(`[data-row="${row}"].grid-cell`);
              const allCellsHaveState = Array.from(rowCells).every(c => 
                c.classList.contains('correct') || 
                c.classList.contains('present') || 
                c.classList.contains('absent')
              );
              
              if (allCellsHaveState) {
                console.log('‚úÖ [Avatar] Validation de mot d√©tect√©e pour ligne:', row);
                
                // Analyser le r√©sultat de la ligne
                const correctCount = Array.from(rowCells).filter(c => c.classList.contains('correct')).length;
                const presentCount = Array.from(rowCells).filter(c => c.classList.contains('present')).length;
                const word = Array.from(rowCells).map(c => c.textContent).join('');
                
                if (correctCount === rowCells.length) {
                  // Mot enti√®rement correct
                  this.triggerAdventureReaction('wordCorrect', { word, correctCount });
                } else if (correctCount > 0 || presentCount > 0) {
                  // Mot partiellement correct
                  this.triggerAdventureReaction('wordPartial', { word, correctCount, presentCount });
                } else {
                  // Mot compl√®tement faux
                  this.triggerAdventureReaction('wordWrong', { word });
                }
              }
            }
          }
        }
      });
    });

    // Observer avec options pour les changements de classes
    this.letterObserver.observe(wordGrid, {
      attributes: true,
      attributeFilter: ['class'],
      subtree: true
    });

    // Observer les entr√©es clavier pour r√©actions l√©g√®res
    this.setupKeyboardObserver();
  }

  setupKeyboardObserver() {
    console.log('‚å®Ô∏è [Avatar] Configuration observateur clavier (r√©actions l√©g√®res)...');
    
    // Observer seulement les √©v√©nements importants du clavier
    document.addEventListener('keydown', (event) => {
      if (!this.isGameActive()) return;
      
      const key = event.key.toUpperCase();
      
      // SEULEMENT Enter et effacement (pas chaque lettre)
      if (key === 'ENTER') {
        this.triggerAdventureReaction('wordSubmitted', { source: 'keyboard' });
      } else if (key === 'BACKSPACE') {
        // R√©action tr√®s l√©g√®re pour l'effacement
        this.triggerAdventureReaction('letterErased', { source: 'keyboard' });
      }
      // Plus de r√©action √† chaque lettre tap√©e
    });

    // Observer les clics sur le clavier virtuel
    const keyboard = document.getElementById('keyboard') || document.querySelector('.keyboard');
    if (keyboard) {
      keyboard.addEventListener('click', (event) => {
        if (!this.isGameActive()) return;
        
        const button = event.target.closest('.key-btn');
        if (button) {
          const keyText = button.textContent.trim();
          
          // SEULEMENT les actions importantes
          if (keyText === 'ENTER') {
            this.triggerAdventureReaction('wordSubmitted', { source: 'virtual' });
          } else if (keyText === '‚å´') {
            this.triggerAdventureReaction('letterErased', { source: 'virtual' });
          }
          // Plus de r√©action √† chaque lettre
        }
      });
    }
  }

  observePowerUps() {
    document.querySelectorAll('.power-up').forEach(powerUp => {
      powerUp.addEventListener('click', () => {
        const type = powerUp.dataset.type;
        this.triggerAdventureReaction('powerUpUsed', { type });
      });
    });
  }

  observeGameState() {
    // Observer les changements d'√©cran de jeu
    const gameArea = document.getElementById('game-area');
    const welcomeScreen = document.getElementById('welcome-screen');
    
    if (gameArea && welcomeScreen) {
      const stateObserver = new MutationObserver(() => {
        if (!gameArea.classList.contains('hidden')) {
          this.triggerAdventureReaction('gameStart', {});
        }
      });
      
      stateObserver.observe(gameArea, { attributes: true, attributeFilter: ['class'] });
      stateObserver.observe(welcomeScreen, { attributes: true, attributeFilter: ['class'] });
    }
  }

  /**
   * D√©clenche une r√©action d'aventure ULTRA-SIMPLIFI√âE
   * FIX√â pour √©viter les erreurs en boucle
   */
  triggerAdventureReaction(eventType, data = {}) {
    try {
      console.log(`üé≠ [Avatar] SIMPLE Adventure reaction: ${eventType}`, data);
      
      const avatar = document.querySelector('#ultra-adventurer');
      if (!avatar) return false;
      // Notify AI brain
      if (this.notifyBrain) {
        this.notifyBrain(eventType, data);
      }
      
      // R√©actions ULTRA-SIMPLIFI√âES sans m√©thodes complexes
      switch (eventType) {
        case 'word_correct':
        case 'word_found':
          this.triggerPhysicalReaction('hop', '0.8s', 2);
          this.showSpeechBubble('Great!', 2000);
          this.changeAura('success', 3000);
        break;
        
        case 'word_invalid':
        case 'word_incorrect':
          this.triggerPhysicalReaction('shake', '0.5s', 3);
          this.showSpeechBubble('Try again!', 2000);
        break;
        
        case 'combo':
        case 'streak':
          // R√©action combo SIMPLIFI√âE
          this.triggerPhysicalReaction('pump', '0.6s', 2);
          this.showSpeechBubble('Combo!', 1500);
          this.changeAura('fire', 2000);
        break;
        
        case 'level_up':
        case 'achievement':
          this.triggerPhysicalReaction('dance', '2s', 2);
          this.showSpeechBubble('Level Up!', 3000);
          this.changeAura('victory', 4000);
        break;
        
        case 'game_start':
          this.triggerPhysicalReaction('nod', '0.5s', 1);
          this.showSpeechBubble('Let\'s go!', 2000);
        break;
        
        case 'game_over':
          this.triggerPhysicalReaction('droop', '1s', 1);
          this.showSpeechBubble('Good try!', 2500);
        break;
        
        case 'powerup_used':
          this.triggerPhysicalReaction('pump', '0.5s', 1);
          this.showSpeechBubble('Power up!', 1500);
          this.changeAura('success', 2000);
        break;
        
      default:
          // R√©action par d√©faut tr√®s simple
          this.triggerPhysicalReaction('gentle', '1s', 1);
          this.showSpeechBubble('Nice!', 1500);
      }
      
      return true;
      
    } catch (error) {
      console.error('‚ùå [Avatar] Erreur r√©action aventure:', error);
      return false;
    }
  }

  /**
   * Observer ULTRA-SIMPLIFI√â pour √©viter les boucles infinies
   */
  observeGameEvents() {
    try {
      console.log('üëÅÔ∏è [Avatar] Observer SIMPLIFI√â activ√©');
      
      // Throttle pour √©viter les appels excessifs
      let lastEventTime = 0;

  // M√©thodes simplifi√©es pour √©viter les erreurs
  createDefaultSpectacle() {
    console.log('üé≠ [Avatar] Creating default spectacle (simplified)');
    this.changeAura('success', 2000);
    return true;
  }
  
  createChampionAura() {
    console.log('üèÜ [Avatar] Creating champion aura (simplified)');
    this.changeAura('victory', 4000);
    return true;
  }
  
  createComboTrail() {
    console.log('üî• [Avatar] Creating combo trail (simplified)');
    this.changeAura('fire', 2500);
    return true;
  }
  
  createFireTrail() {
    console.log('üî• [Avatar] Creating fire trail (simplified)');
    this.changeAura('fire', 3000);
    return true;
  }
  
  createPowerExplosion() {
    console.log('üí• [Avatar] Creating power explosion (simplified)');
    this.changeAura('victory', 3500);
    return true;
  }
  
  /**
   * Nettoie toutes les animations - VERSION ULTRA-ROBUSTE
   */
  clearAllAnimations() {
    try {
      console.log('üßπ [Avatar] Nettoyage COMPLET animations...');
      
      const avatar = document.querySelector('#ultra-adventurer');
      if (avatar) {
        // Reset complet des animations
        avatar.style.animation = '';
        avatar.style.transform = '';
        avatar.style.filter = '';
        avatar.className = avatar.className.replace(/\s*(physical-\w+|spectacle-\w+)\s*/g, ' ');
        
        // Nettoyer l'aura
        this.clearAura();
        
        // Cacher les bulles
        const bubble = avatar.querySelector('.adventure-speech-bubble');
        if (bubble) {
          bubble.style.display = 'none';
        }
        
        console.log('‚úÖ [Avatar] Animations nettoy√©es');
        return true;
      }
      
      return false;
      
    } catch (error) {
      console.error('‚ùå [Avatar] Erreur nettoyage animations:', error);
      return false;
    }
  }

  /**
   * Nettoie l'aura
   */
  clearAura() {
    try {
      const avatar = document.querySelector('#ultra-adventurer');
      if (avatar) {
        const aura = avatar.querySelector('.adventure-aura');
        if (aura) {
          aura.className = 'adventure-aura';
          aura.style.background = '';
          aura.style.animation = '';
        }
      }
    } catch (error) {
      console.error('‚ùå [Avatar] Erreur nettoyage aura:', error);
    }
  }

  /**
   * Affiche une bulle de dialogue
   */
  showSpeechBubble(text, duration = 3000) {
    try {
      const avatar = document.querySelector('#ultra-adventurer');
      if (!avatar) return;
      
      const bubble = avatar.querySelector('.adventure-speech-bubble');
      if (bubble) {
        bubble.textContent = text;
        bubble.style.display = 'block';
        
    setTimeout(() => {
          bubble.style.display = 'none';
        }, duration);
        
        console.log(`üí¨ [Avatar] Bulle: ${text}`);
      }
    } catch (error) {
      console.error('‚ùå [Avatar] Erreur bulle:', error);
    }
  }

  /**
   * D√©clenche une animation physique
   */
  triggerPhysicalAnimation(animationType) {
    try {
      const avatar = document.querySelector('#ultra-adventurer');
      if (!avatar) return;
      
      // Nettoyer anciennes animations
      avatar.className = avatar.className.replace(/\s*animation-\w+/g, '');
      
      // Mapping des alias vers des classes existantes (√©vite les classes manquantes)
      const animationMap = {
        physicalHop: 'physicalBounce',
        physicalDance: 'physicalVictoryDance',
        physicalClap: 'physicalPump',
        physicalTilt: 'physicalWiggle',
        physicalShake: 'physicalFlash',
        physicalFireDance: 'physicalVictoryDance'
      };
      const resolved = animationMap[animationType] || animationType;
      
      // Ajouter nouvelle animation
      avatar.classList.add(`animation-${resolved}`);
      
      // Auto-nettoyage apr√®s animation
      setTimeout(() => {
        avatar.classList.remove(`animation-${resolved}`);
      }, 3000);
      
      console.log(`üé≠ [Avatar] Animation: ${animationType} -> ${resolved}`);
    } catch (error) {
      console.error('‚ùå [Avatar] Erreur animation:', error);
    }
  }

  /**
   * Change l'aura de l'avatar
   */
  changeAura(type, duration = 3000) {
    try {
      const avatar = document.querySelector('#ultra-adventurer');
      if (!avatar) return;
      
      const aura = avatar.querySelector('.adventure-aura');
      if (aura) {
        // Nettoyer ancienne aura
    aura.className = 'adventure-aura';
    
        // Appliquer nouvelle aura
        aura.classList.add(`${type}-aura`);
        
        // Auto-nettoyage
    setTimeout(() => {
      aura.className = 'adventure-aura';
    }, duration);
        
        console.log(`‚ú® [Avatar] Aura: ${type}`);
      }
    } catch (error) {
      console.error('‚ùå [Avatar] Erreur aura:', error);
    }
  }
}

// Styles CSS additionnels pour les nouvelles animations
const additionalStyles = `
  @keyframes attention-pulse {
    0%, 100% { transform: scale(1); border-color: var(--color-primary); }
    50% { transform: scale(1.1); border-color: var(--color-warning); }
  }
  
  @keyframes celebration-bounce {
    0%, 100% { transform: scale(1) rotate(0deg); }
    25% { transform: scale(1.2) rotate(-5deg); }
    50% { transform: scale(1.3) rotate(5deg); }
    75% { transform: scale(1.2) rotate(-2deg); }
  }
  
  @keyframes bounce {
    0%, 100% { transform: translateY(0) scale(1); }
    50% { transform: translateY(-8px) scale(1.1); }
  }
  
  @keyframes wobble {
    0%, 100% { transform: rotate(0deg); }
    25% { transform: rotate(-3deg); }
    75% { transform: rotate(3deg); }
  }
  
  @keyframes tilt {
    0%, 100% { transform: rotate(0deg); }
    50% { transform: rotate(10deg); }
  }
  
  @keyframes droop {
    0% { transform: translateY(0); }
    100% { transform: translateY(3px); }
  }
  
  @keyframes idle-blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
  }
`;

// Injecter les styles
if (!document.getElementById('gameAvatarStyles')) {
  const styleSheet = document.createElement('style');
  styleSheet.id = 'gameAvatarStyles';
  styleSheet.textContent = additionalStyles;
  document.head.appendChild(styleSheet);
}

// Exposer la classe et l'instance globalement
window.GameAvatarIntegration = GameAvatarIntegration;
window.gameAvatarIntegration = null;

// Auto-initialisation FORC√âE (sauf si d√©sactiv√©e)
document.addEventListener('DOMContentLoaded', () => {
  if (window.DISABLE_GAME_AVATAR_INTEGRATION) {
    console.log('üö´ [Avatar] Auto-initialisation d√©sactiv√©e par flag');
    return;
  }
  console.log('üöÄ [Avatar] DOM loaded - Initialisation FORC√âE');
  
  // Attendre un peu que les autres scripts se chargent
  setTimeout(() => {
    if (!window.gameAvatarIntegration) {
      console.log('üöÄ [Avatar] Cr√©ation instance avatar...');
      window.gameAvatarIntegration = new GameAvatarIntegration({
        gameType: 'auto-detect',
        mobileOptimized: true,
        contextualResponses: true
      });
    } else {
      console.log('üîÑ [Avatar] Instance existante d√©tect√©e, red√©marrage...');
      
      // Forcer la recr√©ation de l'avatar
      window.gameAvatarIntegration.createUltraReactiveMiniAdventurer();
      
      // Si on est sur Enigma Scroll, configurer imm√©diatement
      if (window.location.href.includes('enigma-scroll')) {
        setTimeout(() => {
          window.gameAvatarIntegration.initEnigmaScrollIntegration();
        }, 1000);
      }
    }
  }, 1000);
});

// DOUBLE S√âCURIT√â: Si la page est d√©j√† charg√©e (sauf si d√©sactiv√©e)
if (document.readyState === 'complete' || document.readyState === 'interactive') {
  if (window.DISABLE_GAME_AVATAR_INTEGRATION) {
    console.log('üö´ [Avatar] Initialisation imm√©diate d√©sactiv√©e par flag');
  } else {
    console.log('üöÄ [Avatar] Page d√©j√† charg√©e - Initialisation imm√©diate');
  
  setTimeout(() => {
    if (!window.gameAvatarIntegration) {
      window.gameAvatarIntegration = new GameAvatarIntegration({
        gameType: 'auto-detect',
        mobileOptimized: true,
        contextualResponses: true
      });
    }
    
    // Forcer Enigma Scroll si n√©cessaire
    if (window.location.href.includes('enigma-scroll')) {
      setTimeout(() => {
        if (window.gameAvatarIntegration && !window.gameAvatarIntegration.isEnigmaScrollInit) {
          window.gameAvatarIntegration.initEnigmaScrollIntegration();
        }
      }, 2000);
    }
  }, 500);
  }
}

// Couche de compatibilit√© universelle pour l'API window.enigmaAvatar
// S'active uniquement si aucune autre impl√©mentation ne l'a d√©j√† cr√©√©e
(function installEnigmaAvatarCompatibility() {
  if (window.enigmaAvatar) return;

  const ensureIntegration = () => {
    if (!window.gameAvatarIntegration) {
      try {
        window.gameAvatarIntegration = new GameAvatarIntegration({
          gameType: 'auto-detect',
          mobileOptimized: true,
          contextualResponses: true
        });
      } catch (e) {
        console.warn('[Avatar Bridge] Impossible d\'initialiser GameAvatarIntegration:', e);
      }
    }
    return window.gameAvatarIntegration;
  };

  const show = (text, duration = 2500) => {
    const gi = ensureIntegration();
    gi && gi.showSpeechBubble && gi.showSpeechBubble(text, duration);
  };

  const anim = (type) => {
    const gi = ensureIntegration();
    gi && gi.triggerPhysicalAnimation && gi.triggerPhysicalAnimation(type);
  };

  const aura = (type, duration = 3000) => {
    const gi = ensureIntegration();
    gi && gi.changeAura && gi.changeAura(type, duration);
  };

  window.enigmaAvatar = {
    reactToKeyboardClick: () => {},
    reactToLetterDeletion: () => anim('physicalNod'),
    reactToWordSubmission: () => { show('Let\'s see! üëÄ', 1800); anim('physicalPump'); },
    reactToPowerUp: (type) => {
      switch (type) {
        case 'hint':
          show('Hint revealed! üí°', 2000); anim('physicalClap'); aura('success', 2000); break;
        case 'skip':
          show('Skipping ahead! ‚è≠Ô∏è', 2000); anim('physicalHop'); break;
        case 'time':
          show('Time extended! ‚è∞', 2000); anim('physicalVictoryDance'); aura('victory', 3000); break;
        default:
          show('Power up! ‚ö°', 1800); anim('physicalPump'); aura('success', 2000);
      }
    },
    reactToGameStart: () => { show('Game time! üéÆ', 2200); anim('physicalVictoryDance'); },
    reactToNewGame: () => { show('Fresh start! üåü', 1800); anim('physicalHop'); },
    reactToScoreIncrease: (points) => {
      if (points >= 50) { show(`AMAZING! +${points}! üî•`, 3200); anim('physicalSpin'); aura('victory', 4000); }
      else if (points >= 25) { show(`Excellent! +${points}! ‚≠ê`, 2600); anim('physicalPump'); aura('success', 3000); }
      else if (points >= 15) { show(`Good job! +${points}! üëç`, 2200); anim('physicalHop'); aura('success', 2200); }
      else if (points >= 5) { show(`Nice! +${points}! ‚ú®`, 2000); anim('physicalHop'); }
      else { show(`Keep going! +${points}! üåü`, 1800); anim('physicalWiggle'); }
    },
    reactToCombo: (combo) => {
      if (combo >= 7) { show(`COMBO x${combo}! üî•üëë`, 3500); anim('physicalSpin'); aura('fire', 4500); }
      else if (combo >= 5) { show(`Combo x${combo}! üöÄ`, 2800); anim('physicalBounce'); aura('fire', 3500); }
      else if (combo >= 3) { show(`Streak x${combo}! ‚ú®`, 2400); anim('physicalDance'); aura('success', 2800); }
      else if (combo >= 2) { show(`Combo x${combo}! üéØ`, 2000); anim('physicalClap'); }
      else { show('Good start! üí™', 1600); anim('physicalWave'); }
    },
    reactToGameMessage: (message = '') => {
      const m = String(message).toLowerCase();
      if (m.includes('non valide') || m.includes('invalid')) { show('Try again! ü§î', 2000); anim('physicalTilt'); }
      else if (m.includes('incomplet') || m.includes('incomplete')) { show('Complete the word! ‚úçÔ∏è', 2000); anim('physicalNod'); }
      else if (m.includes('temps') || m.includes('time')) { show('Time\'s up! ‚è∞', 2200); anim('physicalDroop'); aura('fire', 2000); }
      else if (m.includes('f√©licitations') || m.includes('bravo') || m.includes('congrats')) { show('Great! üéâ', 2500); anim('physicalVictoryDance'); aura('victory', 3500); }
      else { show(message, 2000); }
    },
    playAnimation: (animationType) => anim(animationType),
    showMessage: (text, duration) => show(text, duration),
    isInitialized: true
  };

  console.log('‚úÖ [Avatar Bridge] API window.enigmaAvatar install√©e (compatibilit√© globale)');
})();

// Export pour usage externe
if (typeof module !== 'undefined' && module.exports) {
  module.exports = GameAvatarIntegration;
} 

// =====================
// Lightweight adaptive Avatar Brain
// =====================
class AvatarBrain {
  constructor(integration, options = {}) {
    this.integration = integration;
    this.options = { tts: false, language: 'fr', ...options };
    this.state = {
      mood: 'neutral', // neutral | happy | excited | focused | tired
      streak: 0,
      lastInteractionAt: Date.now(),
      energy: 70, // 0-100
      tipsLevel: 0,
    };

    // Bind bridge
    integration.notifyBrain = (eventType, data) => this.onEvent(eventType, data);

    // Periodic behaviors
    this._interval = setInterval(() => this.tick(), 15000);
  }

  destroy() { try { clearInterval(this._interval); } catch(_) {} }

  speak(text) {
    try {
      if (this.options.tts && 'speechSynthesis' in window) {
        const utter = new SpeechSynthesisUtterance(text);
        utter.lang = this.options.language.startsWith('fr') ? 'fr-FR' : 'en-US';
        speechSynthesis.speak(utter);
      }
      this.integration.showSpeechBubble?.(text, 2200);
    } catch (_) { /* ignore */ }
  }

  setMood(mood) {
    this.state.mood = mood;
    const auraMap = { happy: 'success', excited: 'victory', focused: 'success', tired: 'fire', neutral: '' };
    const aura = auraMap[mood] || '';
    if (aura) this.integration.changeAura?.(aura, 1800);
  }

  animate(kind = 'gentle') {
    const map = { gentle: 'physicalWiggle', happy: 'physicalHop', excited: 'physicalVictoryDance', focused: 'physicalNod', tired: 'physicalDroop' };
    this.integration.triggerPhysicalAnimation?.(map[kind] || map.gentle);
  }

  rewardSmall() {
    const msgs = ['Bien jou√© ! ‚≠ê','Continue comme √ßa ! üí™','Super ! ‚ú®'];
    this.speak(msgs[Math.floor(Math.random() * msgs.length)]);
    this.animate('happy');
  }

  rewardBig() {
    const msgs = ['INCROYABLE ! üî•','Tu d√©chires ! üëë','Champion ! üèÜ'];
    this.speak(msgs[Math.floor(Math.random() * msgs.length)]);
    this.animate('excited');
    this.setMood('excited');
  }

  encourage() {
    const msgs = ['On s‚Äô\u00accroche ! üéØ','R√©fl√©chis √† une autre combinaison‚Ä¶ üß†','Tu y es presque ! ‚ú®'];
    this.speak(msgs[Math.floor(Math.random() * msgs.length)]);
    this.setMood('focused');
    this.animate('focused');
  }

  tipIfNeeded() {
    if (this.state.tipsLevel <= 0) return;
    const tips = [
      'Essaie une autre terminaison‚Ä¶',
      'Pense aux pr√©fixes et suffixes !',
      'Regarde les lettres d√©j√† correctes pour guider ton choix.',
    ];
    this.speak(tips[(this.state.tipsLevel - 1) % tips.length]);
  }

  miniChallenge() {
    const prompts = ['Trouve un mot en 20s pour gagner un bonus ! ‚è±Ô∏è','Fais un combo x3 ! üöÄ','Deux mots corrects d‚Äôaffil√©e et je danse ! üíÉ'];
    this.speak(prompts[Math.floor(Math.random() * prompts.length)]);
  }

  onEvent(eventType, data) {
    this.state.lastInteractionAt = Date.now();
    switch (eventType) {
      case 'scoreSmallGain':
        this.state.streak++;
        this.state.energy = Math.min(100, this.state.energy + 3);
        if (data.isBig) this.rewardBig();
        else if (data.isMedium) { this.rewardSmall(); this.tipIfNeeded(); }
        else this.rewardSmall();
        if (this.state.streak % 5 === 0) this.miniChallenge();
        break;
      case 'combo':
        this.state.streak += (data.combo || 1);
        (data.isFire ? this.rewardBig() : this.rewardSmall());
        break;
      case 'comboBroken':
      case 'wordWrong':
      case 'wrongWord':
        this.state.streak = 0;
        this.state.energy = Math.max(0, this.state.energy - 5);
        this.encourage();
        break;
      case 'timeRunningOut':
        this.setMood('focused');
        this.speak(`Plus que ${data.timeLeft}s, reste concentr√© ! ‚è∞`);
        break;
      case 'victory':
      case 'wordCorrect':
        this.rewardSmall();
        break;
      case 'gameStart':
        this.setMood('happy');
        this.speak('C‚Äôest parti ! üéÆ');
        break;
      case 'powerUpUsed':
        this.speak('Power up ! ‚ö°');
        this.animate('happy');
        break;
      default:
        if (Math.random() < 0.3) this.animate('gentle');
    }
  }

  tick() {
    const idleSec = (Date.now() - this.state.lastInteractionAt) / 1000;
    if (idleSec > 45) {
      this.state.energy = Math.max(0, this.state.energy - 2);
      if (Math.random() < 0.6) this.encourage();
      if (this.state.energy < 30 && this.state.tipsLevel < 2) this.state.tipsLevel++;
    }
    if (Math.random() < 0.25) {
      const fun = [
        'Je peux faire une danse si tu gagnes +20 points ! üíÉ',
        'On tente un combo ? üî•',
        'Astuce: observe la position des lettres correctes üëÄ',
      ];
      this.speak(fun[Math.floor(Math.random() * fun.length)]);
    }
  }
}